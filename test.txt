===== Ordner: coderr_app =====
----- Inhalt aus: coderr_app/urls.py -----
"""
URL configuration for coderr_app project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from user_auth_app.views import redirect_to_admin, redirect_to_schema
#from drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView

urlpatterns = [
    path('', redirect_to_admin, name='root'),
    #path('', redirect_to_schema, name='root'),
    path('admin/', admin.site.urls),
    path('api/', redirect_to_schema, name='root'),
    path('api/', include('user_auth_app.api.urls')),
    path('api/', include('offers_app.api.urls')),
    path('api/', include('orders_app.api.urls')),
    path('api-auth', include('rest_framework.urls')),
    
    ## API Schema & Doku
    # path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
    # path('api/schema/swagger-ui/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
    # path('api/schema/redoc/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),
]


===== Ordner: offers_app =====
----- Inhalt aus: offers_app/models.py -----
from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator

class Offer(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE,related_name="offers")
    title = models.CharField(max_length=255)
    image = models.ImageField(upload_to='offers/images/', null=True, blank=True)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    min_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    min_delivery_time = models.PositiveIntegerField(validators=[MinValueValidator(1)],null=True, blank=True)
    
    class Meta:
        ordering = ['-updated_at']
    
    def __str__(self):
        return self.title

class OfferDetail(models.Model):
    class OfferType(models.TextChoices):
        BASIC = 'basic', 'basic'
        STANDARD = 'standard', 'standard'
        PREMIUM = 'premium', 'premium'

    offer = models.ForeignKey(Offer, on_delete=models.CASCADE, related_name='details')
    title = models.CharField(max_length=255)
    revisions = models.IntegerField(validators=[MinValueValidator(-1)], default=-1)
    delivery_time_in_days = models.PositiveIntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    features = models.JSONField()
    offer_type = models.CharField(
        max_length=10, 
        choices=OfferType.choices, 
        default=OfferType.BASIC
        )
    
    class Meta:
        unique_together = ('offer', 'offer_type')

    def __str__(self):
        return f"id: {self.id}, title: {self.title}, offer_type: ({self.offer_type})"

----- Inhalt aus: offers_app/views.py -----
from django.shortcuts import render

# Create your views here.
----- Inhalte aus: offers_app/api -----
----- Datei: offers_app/api/serializers.py -----
from django.db import transaction, models
from rest_framework import serializers
from offers_app.models import Offer, OfferDetail
from user_auth_app.api.serializers import UserSerializer



class OfferDetailSerializer(serializers.ModelSerializer):
    price = serializers.DecimalField(max_digits=10, decimal_places=2, coerce_to_string=False)
    class Meta:
        model = OfferDetail
        fields = ['id', 'title', 'revisions', 'delivery_time_in_days', 'price', 'features', 'offer_type']

class OfferSerializer(serializers.ModelSerializer):
    details = OfferDetailSerializer(many=True)
    user_details = UserSerializer(source='user', read_only=True)
    user = serializers.PrimaryKeyRelatedField(read_only=True)
    min_price = serializers.DecimalField(read_only=True, max_digits=10, decimal_places=2)
    min_delivery_time = serializers.IntegerField(read_only=True)
    class Meta:
        model = Offer
        fields = ['id', 'user', 'title', 'image', 'description', 'created_at', 'updated_at', 'details', 'min_price', 'min_delivery_time', 'user_details']

    def validate_details(self, value):
            
            if self.context['request'].method == 'POST':
                if len(value) != 3:
                    raise serializers.ValidationError("Es sind 3 Angebotsdetails erforderlich.")
                
                types = {detail['offer_type'] for detail in value}
                if types != {'basic', 'standard', 'premium'}:
                    raise serializers.ValidationError("Alle drei Typen müssen vorhanden sein.")
            
            
            else:
                seen_types = set()
                for detail in value:
                    offer_type = detail.get('offer_type')
                    if offer_type not in {'basic', 'standard', 'premium'}:
                        raise serializers.ValidationError(f"Ungültiger Typ: {offer_type}")
                    if offer_type in seen_types:
                        raise serializers.ValidationError(f"Doppelter Typ: {offer_type}")
                    seen_types.add(offer_type)
            
            return value

    def create(self, validated_data):
        details_data = validated_data.pop('details')
        with transaction.atomic():
            offer = Offer.objects.create(**validated_data)
            for detail_data in details_data:
                OfferDetail.objects.create(offer=offer, **detail_data)
            agg = offer.details.aggregate(
                min_price=models.Min('price'),
                min_delivery_time=models.Min('delivery_time_in_days')
            )
            offer.min_price = agg['min_price']
            offer.min_delivery_time = agg['min_delivery_time']
            offer.save(update_fields=['min_price', 'min_delivery_time'])
            return offer
    
    def update(self, instance, validated_data):
            details_data = validated_data.pop('details', None)
            
            with transaction.atomic():
                instance = super().update(instance, validated_data)
                
                if details_data is not None:
                    for detail_data in details_data:
                        offer_type = detail_data['offer_type']
                        try:
                            detail = instance.details.get(offer_type=offer_type)
                            for key, value in detail_data.items():
                                setattr(detail, key, value)
                            detail.save()
                        except OfferDetail.DoesNotExist:
                            raise serializers.ValidationError(
                                f"Detail mit Typ {offer_type} existiert nicht"
                            )
                agg = instance.details.aggregate(
                    min_price=models.Min('price'),
                    min_delivery_time=models.Min('delivery_time_in_days')
                )
                instance.min_price = agg['min_price']
                instance.min_delivery_time = agg['min_delivery_time']
                instance.save(update_fields=['min_price', 'min_delivery_time'])
                return instance
   
----- Datei: offers_app/api/permissions.py -----
from rest_framework.permissions import BasePermission

class IsProviderOrReadOnly(BasePermission):
    """Allows only authenticated users to create offers. Read access is granted to everyone."""
    def has_permission(self, request, view):
        if request.method == 'POST':
            return request.user.is_authenticated
        return True

class IsOwnerOrAdmin(BasePermission):
    """Allows only owners or admins to modify objects. Read access is granted to everyone."""
    def has_object_permission(self, request, view, obj):
        if request.method in ['GET', 'HEAD', 'OPTIONS']:
            return True
        return obj.user == request.user or request.user.is_superuser

class OfferPermission(IsProviderOrReadOnly, IsOwnerOrAdmin):
    """Combined permissions for offers, enforcing provider and owner/admin rules."""
    pass

class OfferDetailPermission(IsOwnerOrAdmin):
    """Permissions for offer details, inheriting from IsOwnerOrAdmin but checking the parent offer."""
    def has_object_permission(self, request, view, obj):
        return super().has_object_permission(request, view, obj.offer)
----- Datei: offers_app/api/pagination.py -----
from rest_framework.pagination import PageNumberPagination

class OffersSetPagination(PageNumberPagination):
    page_size = 6
    page_size_query_param = 'page_size'
    max_page_size = 6
----- Datei: offers_app/api/urls.py -----
from django.urls import path, include
from .views import OfferViewSet, OfferDetailRetrieveView
from rest_framework import routers

router = routers.DefaultRouter()
router.register(r'offers', OfferViewSet, basename='offers')

urlpatterns = [
    path('', include(router.urls)),
    path('offerdetails/<int:pk>/', OfferDetailRetrieveView.as_view(), name='offerdetails-detail'),
]


----- Datei: offers_app/api/views.py -----
from rest_framework import viewsets, generics
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter, SearchFilter

from .serializers import OfferSerializer, OfferDetailSerializer
from .permissions import OfferDetailPermission, OfferPermission
from .pagination import OffersSetPagination
from offers_app.models import Offer, OfferDetail


class OfferViewSet(viewsets.ModelViewSet):
    queryset = Offer.objects.all().prefetch_related('details')
    serializer_class = OfferSerializer
    permission_classes = [OfferPermission]
    pagination_class = OffersSetPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter, SearchFilter]
    filterset_fields = ['user', 'details__price', 'details__delivery_time_in_days']
    ordering_fields = ['updated_at', 'min_price']
    search_fields = ['title', 'description']
    
    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class OfferDetailRetrieveView(generics.RetrieveAPIView):
    queryset = OfferDetail.objects.all()
    serializer_class = OfferDetailSerializer
    permission_classes = [OfferDetailPermission]
----- Inhalte aus: offers_app/tests -----
----- Datei: offers_app/tests/test_offers_permission.py -----
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from django.contrib.auth import get_user_model
from rest_framework.authtoken.models import Token
from ..models import Offer, OfferDetail

User = get_user_model()

class OfferPermissionTests(APITestCase):
    def setUp(self):
        """Initialize test users and create sample offer"""
        self.owner = User.objects.create_user(
            username='owner', 
            password='test123', 
            email='owner@example.com'
        )
        self.admin = User.objects.create_superuser(
            username='admin',
            password='admin123',
            email='admin@example.com'
        )
        self.other_user = User.objects.create_user(
            username='other',
            password='other123',
            email='other@example.com'
        )
        
        self.client.force_authenticate(user=self.owner)
        test_data = {
            "title": "Webdesign Package",
            "description": "Professional web development",
            "details": [
                {
                    "title": "Basic",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": 100.00,
                    "features": ["Responsive Design"],
                    "offer_type": "basic"
                },
                {
                    "title": "Standard",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": 200.00,
                    "features": ["CMS Integration"],
                    "offer_type": "standard"
                },
                {
                    "title": "Premium",
                    "revisions": -1,
                    "delivery_time_in_days": 3,
                    "price": 500.00,
                    "features": ["SEO Optimization"],
                    "offer_type": "premium"
                }
            ]
        }
        url = reverse('offers-list')
        response = self.client.post(url, test_data, format='json')
        self.offer_id = response.data['id']
        self.client.logout()

    def test_unauthenticated_user_create(self):
        """Test unauthenticated user cannot create offers"""
        url = reverse('offers-list')
        response = self.client.post(url, {})
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_unauthenticated_user_update(self):
        """Test unauthenticated user cannot update offers"""
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.patch(url, {'title': 'Hacked'})
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_unauthenticated_user_read(self):
        """Test unauthenticated user can read offers"""
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_non_owner_update(self):
        """Test non-owner cannot update offers"""
        self.client.force_authenticate(user=self.other_user)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.patch(url, {'title': 'Hacked'})
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_non_owner_delete(self):
        """Test non-owner cannot delete offers"""
        self.client.force_authenticate(user=self.other_user)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.delete(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

    def test_non_owner_create(self):
        """Test authenticated user can create offers"""
        self.client.force_authenticate(user=self.other_user)
        test_data = {
            "title": "New Offer",
            "description": "New Description",
            "details": [
                {
                    "title": "Basic",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": 100.00,
                    "features": ["Responsive Design"],
                    "offer_type": "basic"
                },
                {
                    "title": "Standard",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": 200.00,
                    "features": ["CMS Integration"],
                    "offer_type": "standard"
                },
                {
                    "title": "Premium",
                    "revisions": -1,
                    "delivery_time_in_days": 3,
                    "price": 500.00,
                    "features": ["SEO Optimization"],
                    "offer_type": "premium"
                }
            ]
        }
        response = self.client.post(reverse('offers-list'), test_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

    def test_admin_update(self):
        """Test admin can update offers"""
        self.client.force_authenticate(user=self.admin)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.patch(url, {'title': 'Admin Updated'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_admin_delete(self):
        """Test admin can delete offers"""
        self.client.force_authenticate(user=self.admin)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.delete(url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)

    def test_owner_update(self):
        """Test owner can update offers"""
        self.client.force_authenticate(user=self.owner)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.patch(url, {'title': 'Owner Updated'})
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['title'], 'Owner Updated')

    def test_owner_delete(self):
        """Test owner can delete offers"""
        self.client.force_authenticate(user=self.owner)
        url = reverse('offers-detail', kwargs={'pk': self.offer_id})
        response = self.client.delete(url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)

class OfferDetailPermissionTests(APITestCase):
    def setUp(self):
        """Initialize test offer details"""
        self.owner = User.objects.create_user(username='owner', password='test123')
        self.offer = Offer.objects.create(
            user=self.owner, 
            title="Test Offer", 
            description="Test Description"
        )
        self.detail = OfferDetail.objects.create(
            offer=self.offer,
            title="Detail",
            revisions=1,
            delivery_time_in_days=1,
            price=100.00,
            features=['Test Feature'],
            offer_type='basic'
        )
        self.url = reverse('offerdetails-detail', kwargs={'pk': self.detail.id})

    def test_non_owner_read_detail(self):
        """Test non-owner can read offer details"""
        other_user = User.objects.create_user(username='other', password='test123')
        self.client.force_authenticate(user=other_user)
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_non_owner_update_detail(self):
        """Test non-owner cannot update offer details"""
        other_user = User.objects.create_user(username='other', password='test123')
        self.client.force_authenticate(user=other_user)
        response = self.client.patch(self.url, {'title': 'Hacked'})
        self.assertEqual(response.status_code, status.HTTP_405_METHOD_NOT_ALLOWED)

    def test_owner_read_detail(self):
        """Test owner can read offer details"""
        self.client.force_authenticate(user=self.owner)
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_owner_update_detail(self):
        """Test owner cannot directly update offer details"""
        self.client.force_authenticate(user=self.owner)
        response = self.client.patch(self.url, {'title': 'Updated'})
        self.assertEqual(response.status_code, status.HTTP_405_METHOD_NOT_ALLOWED)
----- Datei: offers_app/tests/__init.py -----

----- Datei: offers_app/tests/test_offers_filter.py -----
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from rest_framework.authtoken.models import Token
from django.contrib.auth import get_user_model

from ..models import Offer, OfferDetail

User = get_user_model()

class OffersAppFilterTest(APITestCase):
    def setUp(self):
        """Initialize test data for filtering"""
        self.user = User.objects.create_user(
            username='testcustomeruser', 
            password='werte12345', 
            email='customer@gmail.com'
        )
        self.other_user = User.objects.create_user(
            username='otheruser',
            password='otherpass'
        )
        self.token = Token.objects.create(user=self.user)
        self.client = APIClient()
        self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.token.key)

        self.create_offer(
            user=self.user,
            title="Webdesign Paket",
            description="Professionelle Webentwicklung",
            details=[
                {'price': 100, 'delivery': 5, 'type': 'basic'},
                {'price': 200, 'delivery': 7, 'type': 'standard'},
                {'price': 500, 'delivery': 3, 'type': 'premium'}
            ]
        )

        self.create_offer(
            user=self.other_user,
            title="UI Design Paket",
            description="Moderne UI Lösungen",
            details=[
                {'price': 150, 'delivery': 3, 'type': 'basic'},
                {'price': 300, 'delivery': 5, 'type': 'standard'},
                {'price': 700, 'delivery': 2, 'type': 'premium'}
            ]
        )

    def create_offer(self, user, title, description, details):
        """Helper method to create offers with details"""
        offer_data = {
            "user": user.id,
            "title": title,
            "description": description,
            "details": [{
                "title": f"{title} {d['type'].capitalize()}",
                "revisions": 2,
                "delivery_time_in_days": d['delivery'],
                "price": d['price'],
                "features": ["Base Feature"],
                "offer_type": d['type']
            } for d in details]
        }
        response = self.client.post(reverse('offers-list'), offer_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        return response.data

    def test_creator_id_filter(self):
        """Test filtering offers by creator ID"""
        response = self.client.get(reverse('offers-list'), {'creator_id': self.user.id})
        results = response.data['results']
        self.assertEqual(len(results), 2)
        self.assertEqual(results[0]['user'], self.user.id)

    def test_min_price_filter(self):
        """Test filtering offers by minimum price"""
        response = self.client.get(reverse('offers-list'), {'min_price': 200})
        results = response.data['results']
        self.assertEqual(len(results), 2)

    def test_max_delivery_time_filter(self):
        """Test filtering offers by maximum delivery time"""
        response = self.client.get(reverse('offers-list'), {'max_delivery_time': 5})
        results = response.data['results']
        self.assertEqual(len(results), 2)

    def test_search_filter(self):
        """Test searching offers by title and description"""
        response = self.client.get(reverse('offers-list'), {'search': 'Webdesign'})
        results = response.data['results']
        self.assertEqual(len(results), 1)
        self.assertIn('Webdesign', results[0]['title'])

    def test_ordering_by_price(self):
        """Test ordering offers by price"""
        response = self.client.get(reverse('offers-list'), {'ordering': '-min_price'})
        results = response.data['results']
        prices = [result['min_price'] for result in results]
        self.assertEqual(prices, sorted(prices, reverse=True))
----- Datei: offers_app/tests/test_offers.py -----
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from rest_framework.authtoken.models import Token
from django.contrib.auth import get_user_model

from ..models import Offer, OfferDetail

User = get_user_model()

class OffersAppTest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testcustomeruser', password='werte12345', email='customer@gmail.com')
        self.token = Token.objects.create(user=self.user)
        self.client = APIClient(enforce_csrf_checks=True)
        self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.token.key)
        self.offer_data = {
            "title": "Webdesign Paket",
            "description": "Professionelle Webentwicklung",
            "details": [
                {
                    "title": "Basic",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": 100.00,
                    "features": ["Responsive Design"],
                    "offer_type": "basic"
                },
                {
                    "title": "Standard",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": 200.00,
                    "features": ["CMS Integration"],
                    "offer_type": "standard"
                },
                {
                    "title": "Premium",
                    "revisions": -1,
                    "delivery_time_in_days": 3,
                    "price": 500.00,
                    "features": ["SEO Optimierung"],
                    "offer_type": "premium"
                }
            ]
        }
        url = reverse('offers-list')
        response = self.client.post(url, self.offer_data, format='json')
        self.offer = Offer.objects.get(id=response.data['id'])
        
    def test_list_create_offers(self):
        """Tests POST /offers/ endpoint for creating a new offer with three required details."""
        url = reverse('offers-list')
        data = {
            "title": "Grafikdesign-Paket",
            "description": "Ein umfassendes Grafikdesign-Paket für Unternehmen.",
            "details": [
                {
                    "title": "Basic Design",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": "100.00",
                    "features": ["Logo Design","Visitenkarte"],
                    "offer_type": "basic",
                },
                {
                    "title": "Standard Design",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": "200.00",
                    "features": ["Logo Design","Visitenkarte","Briefpapier"],
                    "offer_type": "standard",
                },
                {
                    "title": "Premium Design",
                    "revisions": 10,
                    "delivery_time_in_days": 10,
                    "price": "500.00",
                    "features": ["Logo Design","Visitenkarte","Briefpapier","Flyer"],
                    "offer_type": "premium",
                }
            ]
        }
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Offer.objects.count(), 2)
        new_offer = Offer.objects.get(title='Grafikdesign-Paket')
        self.assertEqual(new_offer.description, 'Ein umfassendes Grafikdesign-Paket für Unternehmen.')
        all_details = new_offer.details.all()
        self.assertEqual(len(all_details), 3, "There should be exactly three detail objects")
        self.assertEqual(new_offer.user, self.user)
    
    def test_get_offers_list(self):
        """GET /offers/ should return all offers"""
        url = reverse('offers-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(Offer.objects.count(), 1)
        self.assertEqual(OfferDetail.objects.count(), 3)
        self.assertEqual(len(response.data), 4)

    def test_get_single_offer(self):
        """GET /offers/{id}/ should return offer details"""
        url = reverse('offers-detail', kwargs={'pk': self.offer.id})
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['title'], self.offer_data['title'])
        self.assertEqual(len(response.data['details']), 3)

    def test_update_offer_title(self):
        """PATCH /offers/{id}/ should update offer"""
        url = reverse('offers-detail', kwargs={'pk': self.offer.id})
        data = {
            'title':'Updated Grafikdesign-Paket',
            'details':[
                    {
                    "title": "Basic Design Updated",
                    "revisions": 3,
                    "delivery_time_in_days": 6,
                    "price": 120.00,
                    "features": ["Logo Design","Flyer"],
                    "offer_type": "basic"
                    }
                ],
            }
        response = self.client.patch(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.offer.refresh_from_db()
        self.assertEqual(self.offer.title, 'Updated Grafikdesign-Paket')

    def test_delete_offer(self):
        """DELETE /offers/{id}/ should delete offer and details"""
        url = reverse('offers-detail', kwargs={'pk': self.offer.id})
        response = self.client.delete(url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Offer.objects.count(), 0)
        self.assertEqual(OfferDetail.objects.count(), 0)

    def test_get_offer_detail(self):
        """GET /offerdetails/{id}/ should return detail"""
        detail = self.offer.details.first()
        url = reverse('offerdetails-detail', kwargs={'pk': detail.id})
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['offer_type'], 'basic')
        self.assertEqual(float(response.data['price']), 100.00)
===== Ordner: orders_app =====
----- Inhalt aus: orders_app/models.py -----
from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator
from offers_app.models import OfferDetail

class Order(models.Model):
    class OfferType(models.TextChoices):
        BASIC = 'basic', 'basic'
        STANDARD = 'standard', 'standard'
        PREMIUM = 'premium', 'premium'
    offer_detail_id = models.ForeignKey(OfferDetail, on_delete=models.PROTECT, related_name="offer_detail_id", null=True)
    customer_user = models.ForeignKey(User, on_delete=models.CASCADE,related_name="customer_user")
    business_user = models.PositiveIntegerField(validators=[MinValueValidator(1)], null=True, blank=True)
    title = models.CharField(max_length=255, blank=True, null=True)
    revisions = models.IntegerField(validators=[MinValueValidator(-1)], default=-1, blank=True, null=True)
    delivery_time_in_days = models.PositiveIntegerField(blank=True, null=True)
    price = models.DecimalField(max_digits=10, decimal_places=2,blank=True, null=True)
    features = models.JSONField(default=list, blank=True, null=True)
    offer_type = models.CharField(max_length=10, choices=OfferType.choices, default=OfferType.BASIC, blank=True, null=True)
    status = models.CharField(default='in_progress',max_length=255, blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return f"id: {self.id}, title: {self.title}, customer_user: {self.customer_user}, busines_user: {self.busines_user},  offer_type: {self.offer_type}"
    

----- Inhalt aus: orders_app/views.py -----
from django.shortcuts import render

# Create your views here.
----- Inhalte aus: orders_app/api -----
----- Datei: orders_app/api/serializers.py -----
from django.db import transaction, models
from rest_framework import serializers

from orders_app.models import Order
from offers_app.models import OfferDetail

class OrderSerializer(serializers.ModelSerializer):
    offer_detail_id = serializers.PrimaryKeyRelatedField(queryset=OfferDetail.objects.all(), write_only=True)
    customer_user = serializers.PrimaryKeyRelatedField(read_only=True)
    class Meta:
        model = Order
        fields = ['id', 'customer_user', 'business_user', 'title', 'revisions', 'delivery_time_in_days', 'price', 'features', 'offer_type', 'status', 'created_at', 'updated_at', 'offer_detail_id']
        read_only_fields = ['id', 'customer_user', 'business_user', 'title', 'revisions', 'delivery_time_in_days', 'price', 'features', 'offer_type', 'created_at', 'updated_at']
        write_only_fields = ['offer_detail_id']
        
    def create(self, validated_data):
        offer = validated_data.pop('offer_detail_id')
        validated_data.update({
            'title': offer.title,
            'revisions': offer.revisions,
            'delivery_time_in_days': offer.delivery_time_in_days,
            'price': offer.price,
            'features': offer.features,
            'offer_type': offer.offer_type,
            'business_user': self.context['request'].user.id
        })
        return super().create(validated_data)
    
----- Datei: orders_app/api/permissions.py -----
from rest_framework.permissions import BasePermission

class CustomerPermission(BasePermission):
    """
    Allows only users with the type "customer" to create new resources.
    This permission only applies to POST requests; all other methods are allowed.
    """
    def has_permission(self, request, view):
        if request.method != 'POST':
            return True
        
        return bool(
            hasattr(request.user, 'profile') and
            request.user.profile.type == 'customer'
        )


class OrderPermission(BasePermission):
    """
    Custom permission class for controlling access to the Order model.
    Grants access to authenticated users.
    - For DELETE requests: Only superusers are allowed to delete the order.
    - For other requests: Users are allowed to perform actions on their own orders.
    """
    def has_permission(self, request, view):
        return request.user.is_authenticated

    def has_object_permission(self, request, view, obj):
        if request.method == 'DELETE':
            return request.user.is_superuser
        return request.user == obj.customer_user
----- Datei: orders_app/api/urls.py -----
from django.urls import path, include
from rest_framework import routers

from .views import OrderViewSet

router = routers.DefaultRouter()
router.register(r'orders', OrderViewSet, basename='orders')

urlpatterns = [
    path('', include(router.urls)),
]


----- Datei: orders_app/api/views.py -----
from rest_framework import viewsets, generics
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter, SearchFilter
from .permissions import OrderPermission, CustomerPermission

from orders_app.models import Order
from .serializers import OrderSerializer

class OrderViewSet(viewsets.ModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [OrderPermission, CustomerPermission]
    
    def get_queryset(self):
        return Order.objects.filter(customer_user=self.request.user)
    
    def perform_create(self, serializer):
        serializer.save(customer_user=self.request.user)
----- Inhalte aus: orders_app/tests -----
----- Datei: orders_app/tests/test_orders_permission.py -----
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from rest_framework.authtoken.models import Token
from django.contrib.auth import get_user_model

from offers_app.models import Offer
from orders_app.models import Order
from user_auth_app.models import UserProfile

User = get_user_model()

class OrderPermissionTests(APITestCase):
    def setUp(self):
        """Initialize test users and create sample order"""
        self.owner = User.objects.create_user(
            username='owner', 
            password='test123', 
            email='owner@example.com'
        )
        self.admin = User.objects.create_superuser(
            username='admin',
            password='admin123',
            email='admin@example.com'
        )
        self.other_user = User.objects.create_user(
            username='other',
            password='other123',
            email='other@example.com'
        )
        self.userprofile = UserProfile.objects.create(
            user=self.owner,
            file='/image.png',
            location='Hamburg',
            tel='+49040123456',
            description='Test',
            working_hours='5',
            type='customer',
            created_at = '2021-08-01T00:00:00Z'
        )
        self.client.force_authenticate(user=self.owner)
        self.offer_data = {
            "title": "Webdesign Paket",
            "description": "Professionelle Webentwicklung",
            "details": [
                {
                    "title": "Basic",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": 100.00,
                    "features": ["Responsive Design"],
                    "offer_type": "basic"
                },
                {
                    "title": "Standard",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": 200.00,
                    "features": ["CMS Integration"],
                    "offer_type": "standard"
                },
                {
                    "title": "Premium",
                    "revisions": -1,
                    "delivery_time_in_days": 3,
                    "price": 500.00,
                    "features": ["SEO Optimierung"],
                    "offer_type": "premium"
                }
            ]
        }
        url = reverse('offers-list')
        response_offer = self.client.post(url, self.offer_data, format='json')
        self.offer = Offer.objects.get(id=response_offer.data['id'])
        response_order = self.client.post(reverse('orders-list'), {"offer_detail_id": 1}, format='json')
        self.order = Order.objects.get(id=response_order.data['id'])
        self.client.logout()
        
    def test_unauthenticated_user_create_order(self):
        """Test unauthenticated user cannot create order"""
        url = reverse('orders-list')
        response = self.client.post(url, {})
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
    
    def test_unauthenticated_user_update_order(self):
        """Test unauthenticated user cannot update orders"""
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        response = self.client.patch(url, {'status':'completed'})
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
    
    def test_unauthenticated_user_read_order(self):
        """Test unauthenticated user can read orders"""
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        
    def test_non_owner_read_orders(self):
        """Test non-owner cannot read order from other users"""
        self.client.force_authenticate(user=self.other_user)
        response = self.client.get(reverse('orders-list'))
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data, [])
    
    def test_non_owner_read_order(self):
        """Test non-owner cannot read an order of another user"""
        self.client.force_authenticate(user=self.other_user)
        response = self.client.get(reverse('orders-detail', kwargs={'pk': self.order.id}))
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
    
    def test_non_owner_update_order(self):
        """Test non-owner cannot update order"""
        self.client.force_authenticate(user=self.other_user)
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        response = self.client.patch(url, {'status': 'completed'})
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
----- Datei: orders_app/tests/__init__.py -----

----- Datei: orders_app/tests/_orders.py -----
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from rest_framework.authtoken.models import Token
from django.contrib.auth import get_user_model

from offers_app.models import Offer
from orders_app.models import Order
from user_auth_app.models import UserProfile

User = get_user_model()

class OrderAppTest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testcustomeruser', password='werte12345', email='customer@gmail.com')
        self.token = Token.objects.create(user=self.user)
        self.userprofile = UserProfile.objects.create(
            user=self.user,
            file='/image.png',
            location='Hamburg',
            tel='+49040123456',
            description='Test',
            working_hours='5',
            type='customer',
            created_at = '2021-08-01T00:00:00Z'
        )
        self.client = APIClient(enforce_csrf_checks=True)
        self.client.credentials(HTTP_AUTHORIZATION='Token ' + self.token.key)
        self.offer_data = {
            "title": "Webdesign Paket",
            "description": "Professionelle Webentwicklung",
            "details": [
                {
                    "title": "Basic",
                    "revisions": 2,
                    "delivery_time_in_days": 5,
                    "price": 100.00,
                    "features": ["Responsive Design"],
                    "offer_type": "basic"
                },
                {
                    "title": "Standard",
                    "revisions": 5,
                    "delivery_time_in_days": 7,
                    "price": 200.00,
                    "features": ["CMS Integration"],
                    "offer_type": "standard"
                },
                {
                    "title": "Premium",
                    "revisions": -1,
                    "delivery_time_in_days": 3,
                    "price": 500.00,
                    "features": ["SEO Optimierung"],
                    "offer_type": "premium"
                }
            ]
        }
        url = reverse('offers-list')
        response_offer = self.client.post(url, self.offer_data, format='json')
        self.offer = Offer.objects.get(id=response_offer.data['id'])
        response_order = self.client.post(reverse('orders-list'), {"offer_detail_id": 1}, format='json')
        self.assertEqual(response_order.status_code, status.HTTP_201_CREATED)
        self.order = Order.objects.get(id=response_order.data['id'])
    
    def test_create_order_list(self):
        """Tests POST /orders/ endpoint for creating a new order based on a offers details."""
        url = reverse('orders-list')
        data = {"offer_detail_id": 2}
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Order.objects.count(), 2)
        new_order = Order.objects.get(title='Standard')
        self.assertEqual(new_order.revisions, 5)
    
    def test_get_order_list(self):
        """GET /orders/ should return all orders"""
        url = reverse('orders-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(Order.objects.count(), 1)
        self.assertEqual(len(response.data), 1)
        
    def test_get_single_order(self):
        """GET /orders/{id}/ should return order details"""
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        response = self.client.get(url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['title'], self.offer_data['details'][0]['title'])
    
    def test_patch_order_status(self):
        """PATCH /orders/{id}/ should update order status"""
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        data = {'status':'completed'}
        response = self.client.patch(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.order.refresh_from_db()
        self.assertEqual(self.order.status, 'completed')
        
    def test_delete_offer_unauthorized(self):
        """DELETE /order/{id}/ should delete order"""
        url = reverse('orders-detail', kwargs={'pk': self.order.id})
        response = self.client.delete(url)
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)

        
    
===== Ordner: user_auth_app =====
----- Inhalt aus: user_auth_app/models.py -----
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone

class UserProfile(models.Model):
    class UserType(models.TextChoices):
        BUSINESS = 'business', 'business'
        CUSTOMER = 'customer', 'customer'
    user = models.OneToOneField(User, on_delete=models.CASCADE, primary_key=True, related_name='profile')
    file = models.ImageField(upload_to='profile_pics/', blank=True, null=True)
    location = models.CharField(max_length=100, blank=True, null=True)
    tel = models.CharField(max_length=20, blank=True, null=True)
    description= models.TextField(blank=True, null=True)
    working_hours = models.CharField(max_length=100, blank=True, null=True)
    type = models.CharField(max_length=8, choices=UserType.choices, default=UserType.CUSTOMER)
    created_at = models.DateTimeField(default=timezone.now)
    uploaded_at = models.DateTimeField(blank=True, null=True)
    

    def __str__(self):
        return self.user.username

----- Inhalt aus: user_auth_app/views.py -----
from django.shortcuts import render
from django.shortcuts import redirect


def redirect_to_admin(request):
    """
    Redirects the user to the Django admin interface.
    Args:
        request (HttpRequest): The HTTP request object.
    Returns:
        HttpResponseRedirect: A redirect response to the Django admin index page.
    """
    
    return redirect('admin:index')

def redirect_to_schema(request):
    """
    Redirects the user to the API schema page.
    """
    return redirect('swagger-ui')
----- Inhalte aus: user_auth_app/api -----
----- Datei: user_auth_app/api/serializers.py -----
from rest_framework import serializers
from django.contrib.auth.models import User
from user_auth_app.models import UserProfile


class RegistrationSerializer(serializers.ModelSerializer):
    repeated_password = serializers.CharField(write_only=True)
    type = serializers.ChoiceField(choices=UserProfile.UserType.choices, write_only=True)

    class Meta:
        model = User
        fields = ['username', 'email', 'password', 'repeated_password', 'type']
        extra_kwargs = {
            'password': {'write_only': True},
            'email':{
                'error_messages': {
                    'blank': {'email':['Dieses Feld darf nicht leer sein.']},
                    'invalid': {'email':'E-Mail-Format ist ungültig.'},
                    'unique': {'email':['Diese E-Mail-Adresse wird bereits verwendet.']}
                }
            }
        }

    def validate(self, data):
        if data['password'] != data['repeated_password']:
            raise serializers.ValidationError({'password': ['Das Passwort ist nicht gleich mit dem wiederholten Passwort']})
        return data

    def validate_username(self, value):
        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError({'username':['Dieser Benutzername ist bereits vergeben.']})
        return value
    
    def save(self):
        
        username = self.validated_data['username']
        email = self.validated_data['email']
        password = self.validated_data['password']
        user_type = self.validated_data['type']

        user = User(username=username, email=email)
        user.set_password(password)
        user.save()
        
        UserProfile.objects.create(user=user, type=user_type)
        return user


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'username']

class UserProfileSerializer(serializers.ModelSerializer):
    user = serializers.IntegerField(source='user.id', read_only=True)
    username = serializers.CharField(source='user.username')
    email = serializers.EmailField(source='user.email')
    
    class Meta:
        model = UserProfile
        fields = ['user', 'username', 'email', 'file', 'location', 'tel', 'description', 'working_hours', 'type', 'created_at']
        read_only_fields = ['user', 'created_at']

      
class UserProfileBusinessSerializer(serializers.ModelSerializer):
    pk = serializers.IntegerField(source='user.id', read_only=True)
    username = serializers.CharField(source='user.username', read_only=True)
    first_name = serializers.EmailField(source='user.first_name', read_only=True)
    last_name = serializers.EmailField(source='user.last_name', read_only=True)
    
    class Meta:
        model = UserProfile
        fields = ['pk', 'username', 'first_name', 'last_name', 'file', 'location', 'tel', 'description', 'working_hours', 'type']


class UserProfileCustomerSerializer(serializers.ModelSerializer):
    pk = serializers.IntegerField(source='user.id', read_only=True)
    username = serializers.CharField(source='user.username', read_only=True)
    first_name = serializers.EmailField(source='user.first_name', read_only=True)
    last_name = serializers.EmailField(source='user.last_name', read_only=True)
    
    class Meta:
        model = UserProfile
        fields = ['pk', 'username', 'first_name', 'last_name', 'file', 'uploaded_at', 'type']
----- Datei: user_auth_app/api/permissions.py -----
from rest_framework.permissions import BasePermission

class ProfilePermission(BasePermission):
        
    def has_permission(self, request, view):
        return request.user.is_authenticated

    def has_object_permission(self, request, view, obj):
        if request.method == 'DELETE'  or request.method == 'PUT' or request.method == 'POST':
            return request.user.is_superuser
        return request.user == obj.user
----- Datei: user_auth_app/api/urls.py -----
from django.urls import path
from .views import RegistrationView, UserProfileDetail, UserProfileBusinessList,UserProfileCustomerList, CustomLoginView


urlpatterns = [
    path('profile/<int:pk>/', UserProfileDetail.as_view(), name='userprofile-detail'),
    path('profiles/business/', UserProfileBusinessList.as_view(), name='userprofile-business-list'),
    path('profiles/customer/', UserProfileCustomerList.as_view(), name='userprofile-customer-list'),
    path('registration/', RegistrationView.as_view(), name='registration'),
    path('login/', CustomLoginView.as_view(), name='login'),
]
----- Datei: user_auth_app/api/views.py -----
from rest_framework import status, viewsets, generics
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.authtoken.models import Token
from rest_framework.authtoken.views import ObtainAuthToken
from rest_framework.response import Response

from user_auth_app.models import UserProfile
from user_auth_app.api.permissions import ProfilePermission
from .serializers import RegistrationSerializer, UserProfileSerializer, UserProfileBusinessSerializer, UserProfileCustomerSerializer

class RegistrationView(APIView):
    permission_classes = [AllowAny]
    
    def post(self, request):
        serializer = RegistrationSerializer(data=request.data)
        if serializer.is_valid():
            saved_accound = serializer.save()
            token, created = Token.objects.get_or_create(user=saved_accound)
            data = {
                'token' : token.key,
                'username' : saved_accound.username,
                'email' : saved_accound.email,
                'user_id' : saved_accound.id
            }
            return Response(data, status=status.HTTP_200_OK)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class CustomLoginView(ObtainAuthToken):
    permission_classes = [AllowAny]
    
    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        
        data = {}
        if serializer.is_valid():
            user = serializer.validated_data['user']
            token, created = Token.objects.get_or_create(user=user)
            data = {
                'token' : token.key,
                'username' : user.username,
                'email' : user.email,
                'user_id' : user.id
            }
            return Response(data, status=status.HTTP_200_OK)
        else:
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class UserProfileDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = UserProfile.objects.all()
    serializer_class = UserProfileSerializer
    permission_classes = [ProfilePermission]
    
    def get_object(self):
        obj = UserProfile.objects.get(user_id=self.kwargs['pk'])
        self.check_object_permissions(self.request, obj)
        return obj
    
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)

        user_data = serializer.validated_data.pop('user', {})
        user = instance.user
        if 'username' in user_data:
            user.username = user_data['username']
        if 'email' in user_data:
            user.email = user_data['email']
        user.save()
        
        self.perform_update(serializer)
        return Response(serializer.data)
    
class UserProfileBusinessList(generics.ListAPIView):
    queryset = UserProfile.objects.filter(type=UserProfile.UserType.BUSINESS)
    serializer_class = UserProfileBusinessSerializer
    permission_classes = [ProfilePermission]
    
class UserProfileCustomerList(generics.ListAPIView):
    queryset = UserProfile.objects.filter(type=UserProfile.UserType.CUSTOMER)
    serializer_class = UserProfileCustomerSerializer
    permission_classes = [ProfilePermission]

